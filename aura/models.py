# -*- coding: utf-8 -*-

import datetime #<- will be used to set default dates on models
#from aura.models import Base  #<- we need to import our sqlalchemy metadata from which model classes will inherit
from sqlalchemy import (
    Column,
    Integer,
	Float,
	Boolean,
    Unicode,     #<- will provide Unicode field
    Text,
    UnicodeText, #<- will provide Unicode text field
    DateTime,    #<- time abstraction field
    ForeignKey,
    )

import sqlalchemy as sa
from paginate_sqlalchemy import SqlalchemyOrmPage #<- provides pagination

from sqlalchemy.ext.declarative import declarative_base

from sqlalchemy.orm import (
    scoped_session,
    sessionmaker,
    )

from  sqlalchemy.sql.expression import func

from zope.sqlalchemy import ZopeTransactionExtension

DBSession = scoped_session(sessionmaker(extension=ZopeTransactionExtension()))
Base = declarative_base()

from webhelpers2.text import urlify #<- will generate slugs
from webhelpers2.date import distance_of_time_in_words #<- human friendly dates

from passlib.apps import custom_app_context as blogger_pwd_context
from pyramid.security import (
	Allow,
	Everyone)

class User(Base):
	__tablename__ = 'users'
	id = Column(Integer, primary_key=True)
	name = Column(Unicode(255), unique=True, nullable=False)
	password = Column(Unicode(255), nullable=False)
	group_id = Column(Integer)
	avatar_id = Column(Integer, ForeignKey('images.id'))
	registrated = Column(DateTime, default=datetime.datetime.utcnow)
	last_logged = Column(DateTime, default=datetime.datetime.utcnow)
	
	def verify_password(self, password):
		#if password == self.password:
		#	self.set_password(password)
		#	return blogger_pwd_context.verify(password, self.password)
		return self.password == password#n
		
		
	def set_password(self, password):
		password_hash = blogger_pwd_context.encrypt(password)
		#self.password = password_hash
		self.password = password#n
	
	@classmethod
	def by_id(cls, id):
		return DBSession.query(User).filter(User.id == id).first()
	
	@classmethod
	def by_name(cls, name):
		return DBSession.query(User).filter(User.name == name).first()
	
	@classmethod
	def last_registrated(cls):
		return DBSession.query(User).order_by(sa.desc(User.registrated)).first()

class UserService(object):
	
	@classmethod
	def by_name(cls, name):
		return DBSession.query(User).filter(User.name == name).first()
	

class BlogRecord(Base):
	__tablename__ = 'entries'
	id = Column(Integer, primary_key=True)
	author_id=Column(Integer, ForeignKey('users.id'))
	title = Column(Unicode(255), default=u'', unique=True, nullable=False)
	body = Column(UnicodeText, default=u'')
	created = Column(DateTime, default=datetime.datetime.utcnow)
	edited = Column(DateTime, default=datetime.datetime.utcnow)
	
	@classmethod
	def update_edited(self):
		self.edited = datetime.datetime.utcnow
	
	@classmethod
	def by_id(cls, id):
		return DBSession.query(BlogRecord).filter(BlogRecord.id == id).first()
	
	@classmethod
	def get_lastpages_id(cls, num):
		return DBSession.query(BlogRecord).order_by(sa.desc(BlogRecord.created)).limit(num).all()
	
	@property
	def slug(self):
		return urlify(self.title)
	
	@property
	def created_in_words(self):
		return distance_of_time_in_words(self.created,
										 datetime.datetime.utcnow())
	
	@classmethod
	def get_paginator(cls, query, request, page=1):
		query_params = request.GET.mixed()
		
		def url_maker(link_page):
			# replace page param with values generated by paginator
			query_params['page'] = link_page
			return request.current_route_url(_query=query_params)
		
		return SqlalchemyOrmPage(query, page, items_per_page=5, url_maker=url_maker)
	
	
class BlogRecordService(object):
		
	@classmethod
	def all(cls):
		return DBSession.query(BlogRecord).order_by(sa.desc(BlogRecord.created))
	
	@classmethod
	def by_id(cls, id):
		return DBSession.query(BlogRecord).filter(BlogRecord.id == id).first()
	
	@classmethod
	def get_paginator(cls, request, page=1):
		query = DBSession.query(BlogRecord).order_by(sa.desc(BlogRecord.created))
		query_params = request.GET.mixed()
		
		def url_maker(link_page):
			# replace page param with values generated by paginator
			query_params['page'] = link_page
			return request.current_route_url(_query=query_params)
		
		return SqlalchemyOrmPage(query, page, items_per_page=5, url_maker=url_maker)
	
	
class Image(Base):
	__tablename__ = 'images'
	id = Column(Integer, primary_key=True)
	name = Column(Text)
	image_name = Column(Text)
	gallery = Column(Boolean, default=False)
	
	def __repr__(self):
		return self.name
	
	@classmethod
	def by_id(cls, id):
		return DBSession.query(Image).filter(Image.id == id).first()
	
	@classmethod
	def get_gallery(cls):
		return DBSession.query(Image).filter(Image.gallery == True)
	
	@classmethod
	def get_random(cls):
		return DBSession.query(Image).order_by(func.random()).first()
	
	@classmethod
	def get_paginator(cls, query, request, page=1):
		query_params = request.GET.mixed()
		
		def url_maker(link_page):
			# replace page param with values generated by paginator
			query_params['page'] = link_page
			return request.current_route_url(_query=query_params)
		
		return SqlalchemyOrmPage(query, page, items_per_page=1, url_maker=url_maker)
	
class Video(Base):
	__tablename__ = 'videos'
	id = Column(Integer, primary_key=True)
	name = Column(Text)
	url = Column(Text)
	
	def __repr__(self):
		return self.name
	
	@classmethod
	def by_id(cls, id):
		return DBSession.query(Video).filter(Video.id == id).first()
	
	@classmethod
	def get_random(cls):
		return DBSession.query(Video).order_by(func.random()).first()
	
	@classmethod
	def get_paginator(cls, query, request, page=1):
		query_params = request.GET.mixed()
		
		def url_maker(link_page):
			# replace page param with values generated by paginator
			query_params['page'] = link_page
			return request.current_route_url(_query=query_params)
		
		return SqlalchemyOrmPage(query, page, items_per_page=4, url_maker=url_maker)
	
	
class Music(Base):
	__tablename__ = 'musics'
	id = Column(Integer, primary_key=True)
	name = Column(Text)
	url = Column(UnicodeText, default=u'')
	
	def __repr__(self):
		return self.name
	
	@classmethod
	def by_id(cls, id):
		return DBSession.query(Music).filter(Music.id == id).first()
	
	@classmethod
	def get_random(cls):
		return DBSession.query(Music).order_by(func.random()).first()
	
	@classmethod
	def get_paginator(cls, query, request, page=1):
		query_params = request.GET.mixed()
		
		def url_maker(link_page):
			# replace page param with values generated by paginator
			query_params['page'] = link_page
			return request.current_route_url(_query=query_params)
		
		return SqlalchemyOrmPage(query, page, items_per_page=4, url_maker=url_maker)

	
	
class Score(Base):
	__tablename__ = 'scores'
	id = Column(Integer, primary_key=True)
	user_id = Column(Integer, ForeignKey('users.id'))
	result = Column(Float)
	
	def __repr__(self):
		return self.id
	